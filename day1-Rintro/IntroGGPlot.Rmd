---
title: "Conding club: Introduction to GGPlot"
author: "David Souto"
date: "2022-12-03"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#()
```

My plan for this first series of the coding club is to empower you / us in using R for data visualization by giving you rather extensive information allowing you to understand better how things are organized in R, how to help yourself and troubleshoot things.  

To do so I think it would be best to take our sweet time building from basic examples to something more complex. At the end of a series of sessions (we can take as many as we deem necessary) you should be able to be produce custom publication-quality graphs that are ready to submit to a journal.

I'll start with boring bits, but you'll thank me later.

### The plan
* Package installation 
* Helping yourself (?/??/Help/Vignettes)
* Loading data / using available datasets
* GGplot grammar of graphics
  * accetable data
  * Geometry: geom_
  * Stats: stats_
  * Position: position_
  * Aesthetic: aes_
  * Scale: scale_
  * Coordinates: coord_ 
  * Facets: facets_
* You gotta save them fancy plots

I'll start by noting that a lot of what I am going to say is following quite closely two excellent and freely available references. One is extremely comprehensive, "GGplot2: Elegant graphics for data analysis" <https://ggplot2-book.org/introduction.html> and the other probably more suited to our needs: "R for data science" (Data visualization chapter) <https://r4ds.had.co.nz/index.html>. 

What I'll do not cover in this series (but one of us could later on!) is address data wrangling.

At the end of the session feel free to send me examples of things you aren't able to figure out so we can do this together.

## Package installation

The first hurdle in R is to install packages.
Comment this after you install, you only need to do it once (unless you change computers) but keeping it there simplifies the life of others
the tidyverse one is a “super-package”, containing many smaller ones. I installed the “stats” package one, but just to make a point!
note the tidyverse package will install ggplot2 already, I could install separately

```{r eval=FALSE}
install.packages(c("colorBlindness", "tidyverse"))
```
  
```{r eval=TRUE}
library(colorBlindness,tidyverse)
```

```{r echo=FALSE, out.width = "30%"}
tidyverse_logo()
knitr::include_graphics("tidyverse_packages.png") 
```

You can also access those conflicts with tidyverse_conflicts(). See which other packages are installed under the tidyverse umbrella with 
tidyverse_packages()

## Understanding R namespace helps
Common error source: Little consistency at times. E.g. library(tidyverse,ggplot2) works, install.packages(tidyverse,gglplot2) doesn’t

Problems with functions that "mask" other functions!

We access to the elements of a structure in R with with the **$** sign but we also go the **::** to access the elements of a package (a group of functions sharing the same name)

What are functions belonging to tidyverse package (a bunch of different packages more like)? Two functions can have the same name within different packages!! 
Check the output: it tells you already about possible problems!  

How do I know what a function belongs to …? ?dplyr then I see on top dplyr_package{dplyr}
You need to load too! library(XXX) or library("package")

You don't know which function belongs to? Quick trick: t.test instead of t.test() (which won't run)

# Helping yourself

```{r}
# execute line-by-line with Ctrl+Enter
?colorBlindness
??colorBlindness
vignette("colorBlindness") #is neat but not everything has a vignette
```

Start by the end and run the examples within the help and use what you know about the namespace: e.g. not ?tibble, but ?tibble::tibble, then "Run examples" to see the output directly without copy and pate

# GGplot intro
Some terminology. It is called a grammar because you have different elements that you add by layers, like verbs and adjectives they transform the visualization in some way, as those transform meaning. In a traditional scenario you can't just change things by addition **+**. Note that there is no shame however in using the base functions for plotting, sometimes they offer more liberty and are handier. Often however ggplot will be quicker and allow you to try different visualizations of the same data quickly which is what you want. 

From: https://r4ds.had.co.nz/index.html#welcome

```{r eval=FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

We are going to follow those different elements.but first we need to see what type of data is acceptable

# Loading data
GGplot2 is pre-loaded with a bunch of datasets you can use for trying some ideas first. 

Let's look at the mpg dataset. It says it is a tibble

How you create a tibble?
```{r eval=FALSE}
mpg
```
What if you got something else and want to transform to a 234 x 11 tibble?, let's see ?tibble. It is part of the tidyverse.

You have tibble(), as_tibble() and tribble()

e.g.create a tibble (based on preloaded data **trees** and **Titanic**)

```{r}
tibble(
      a = 1:3,
     b = diag(3),
     c = cor(trees),
     d = Titanic[1:3, , , ]
)

```

You make a matrix data set and transform it to a tibble

```{r}
m <- matrix(rnorm(50), ncol = 5)
colnames(m) <- c("a", "b", "c", "d", "e")
df <- as_tibble(m)
```

What does ggplot make of m?
```{r}
ggplot(m)
```

What is a data.frame?
We understand it is part of the base package: ?data.frame

```{r}
L3 <- LETTERS[1:3]
char <- sample(L3, 10, replace = TRUE)
(d <- data.frame(x = 1, y = 1:10, char = char))
```

What can ggplot make out of it?

```{r}
ggplot(d)
```

So we now have two ways to speak / feed data to ggplot

Let's start by the simplest plot using the trees data. How can we check the type of data it is?

We can make it a tibble if we want with as_tibble(trees). Can check what it is with is.data.frame(trees), but it is much more clever to use the generic function for this: class(trees)

```{r}
  ggplot(trees, aes(x=Girth,y=Height))
```

Where is the data / where does it come from? ?trees, ?mpg

```{r}

# this says we want the x axis to represent the girth variable, the y axis to represent height
ggplot(trees)+
  geom_point(aes(x=Girth,y=Height))

# more explicitly
ggplot(data=trees)+
  geom_point(mapping=aes(x=Girth,y=Height))

## we can also get a handle we can reuse later
graph_handle<-ggplot(trees)+
  geom_point(mapping=aes(x=Girth,y=Height))

# I can do this as well
graph_handle<-ggplot(trees, aes(x=Girth,y=Height))+
  geom_point()

# then display with the handle or add to it
graph_handle

# e.g
# graph_handle + ...
  
# What happens if you enter graph_handle?

# What's with the geom_point? The geom_* refers to specifying the geometry of the plot ..., each "geometry" will have its function
# examples are geom_point, geom_smooth, geom_bar; we'll look at where to find them all at the end
# note that ?geom_point works

# other things I can map to the third variable
ggplot(trees) + 
  geom_point(aes(x = Girth, y = Height, color = Volume))

# won't work for a continuous variable? How to change to a factor?
#...as.factor()
trees$Volume<-as.factor(trees$Volume)

# errors: see how a missing bracket here generates spurious errors next
# fix the first error

ggplot(trees)+ 
  geom_point(aes(x = Girth, y = Height, size = Volume))

ggplot(trees) + 
  geom_point(aes(x = Girth, y = Height, alpha = Volume))


ggplot(trees) + 
  geom_point(aes(x = Girth, y = Height, shape = Volume))

ggplot(trees)+ 
  geom_point(aes(x = Girth, y = Height, color = Volume))

# or I can define the value of any of those
ggplot(trees)+ 
  geom_point(aes(x = Girth, y = Height, color = "red"))

# lets use another dataset where this makes sense
# remember, use the mpg$ to find the names, no need to look them up
ggplot(mpg)+ 
  geom_point(aes(x = model, y = displ, color = class)) #later: +coord_flip()

# easy-pizzy, lets flip the x and y
ggplot(mpg)+ 
  geom_point(aes(x = displ, y = model, color = class)) #later: +coord_flip()

# as usual there are many ways to do things: +coord_flip()

# now I can't really read the model information, 

# often we'll want points and averages as well, and link the dots
# and perhaps have different colours depending on the conditions ...

# what happens if I apply this to another "aesthetic", with our cars
# this is where the ggplot magic happens, we don't need to change anything, just
# apply a different "geom_"
ggplot(mpg, aes(x=displ, y=model,color=class)) + 
  geom_boxplot()

# what if I want to connect the averages with a line? we can do that but we need to operate on the averages ..., we'll see this later: geom_path() + geom_point()

```

# Facets

What if we want different panels? We add another layer called facet_

Example of use

```{r}
ggplot(mpg,aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~ class, nrow = 3)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)

# or (e.g. in ?facet_wrap)
ggplot(mpg,aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(vars(class), nrow = 3)
```
  
# Labels

```{r}

plot_handle<-ggplot(mpg,aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~ class, nrow = 3)

second_plot_handle<-plot_handle+labs(x="engine displacement", y="highway miles per gallon", title="car stuff", caption="more car stuff", alt="alt text, accessiblity?") # note we can have more than one geom

# I can label the points as well with geom_text(); see geom_label() for a variant 
ggplot(mpg, aes(x=displ, y=hwy, label = model))+geom_text()


```

# Coordinates & scales
```{r second_plot_handle}

# common
p<-second_plot_handle+coord_cartesian(xlim=c(2,6),ylim=c(10,20))+
coord_equal(ratio=1)+ # fix the aspect ratio
coord_flip()+
coord_trans(x = "log10", y="identity") # less explicit (x=)  

# lets try this:
second_plot_handle+coord_trans(x = "log10", y="identity") #options are 
second_plot_handle+coord_trans(x=scales::log10_trans()) # note can't be retrieved without scales::
second_plot_handle+scale_x_log10() 

# I'll show you a few ways we can put this so you are not confused next time you see this otherwise

```


# Statistics 

What if you want to combine different datasets into the same graph (the individual means and the average?)
We have seen that geom_boxplot() does that for you, it is not only a geometric transformation but it does calculate some statistics based on the factors you are feeding. But what control do I have on those statistics? Let's see

```{r p}
# note how you can actually specify statistical calculations in this geom, e.g. coef
# note also that you can feed data that coudl be different from the data inherited from the ggplot() function
geom_boxplot()

# lets have a look at another, very common stats_ function:
# lets put everything together first
ggplot(mpg,aes(x=displ,y=hwy))+
  geom_point()+
  stat_summary(fun.data = "mean_cl_boot", colour = "red") # there is a linewidth and size option

# orientation following discrete axis ... we can also supply individual functions (mean_cl_boot does many things for you), by fun = "mean" for instance

# Add a line: 
ggplot(mpg,aes(x=displ,y=hwy))+
  geom_point()+
  stat_summary(fun.data = "mean_cl_boot", colour = "red", geom="line") # there is a linewidth and size option

# or both a line and a point
ggplot(mpg,aes(x=displ,y=hwy))+
  geom_point()+
  stat_summary(fun.data = "mean_cl_boot", colour = "red", geom="line")+ # there is a linewidth and size 
  stat_summary(fun.data = "mean_cl_boot", colour = "red", geom="point") # there is a linewidth and size 

```

# What about error bars?

```{r}

# example with standard error, other possiblity is mean_sd1; remember fun and fun.data are not the same
ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + geom_point() +
  stat_summary(fun.data="mean_se",color="red", linewidth=1, size=1)
  
# RFDS: “If you place mappings in a geom function, ggplot2 will treat them as local mappings for the layer. It will use #these mappings to extend or overwrite the global mappings for that layer only. This makes it possible to display #different aesthetics in different layers.”
#ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
#  geom_point(mapping = aes(color = class)) + 
#  geom_smooth()

# but we want different groupings, no?
ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1, aes(color=trans))+
  stat_summary(fun="mean", linewidth=2, size=1, aes(color=trans), geom="line") # don't forget fun for individual values

# we could also add a fit
ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1, aes(color=trans))+
  stat_summary(fun="mean", linewidth=2, size=1, aes(color=trans), geom="line")+    
  geom_smooth() # are you very interested in this? we could expand on the nitty gritty

# RFDS: "You can tidy up the code to ease reading"
#ggplot(data = diamonds) + 
#  stat_summary(
#    mapping = aes(x = cut, y = depth),
#    fun.min = min,
#    fun.max = max,
#    fun = median
#  )

# note I can use the filter function too
# e.g. + geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)

# other example

# if you have done the calculation elsewhere
geom_errorbar()
geom_pointrange()

#etc.

# first example from ?geom_errorbar()
df <- data.frame(
  trt = factor(c(1, 1, 2, 2)),
  resp = c(1, 5, 3, 4),
  group = factor(c(1, 2, 1, 2)),
  upper = c(1.1, 5.3, 3.3, 4.2),
  lower = c(0.8, 4.6, 2.4, 3.6)
)

p <- ggplot(df, aes(trt, resp, colour = group))
  
```

# What about 2D data?

```{r p}

# here is a quick exmaple
stat_summary2D() # alias of stat_summary_2D()
d <- ggplot(diamonds, aes(carat, depth, z = price))
d + stat_summary_2d()

```

# Themes

The default theme is not great to tell the truth but there is a lot of leeway there too. Edward Tufte recommendations: minimize the ink. Perhaps we can add perceptual factors that make things more or less cluttered on one hand and hard too see on the other (e.g. differentiate conditions by small shapes)

We are following the advice here:
<https://ben-williams.github.io/updated_ggplot_figures.html>

```{r}
# higher level function theme_, theme black and white:
p<-ggplot(mtcars, aes(wt, mpg)) + 
  geom_point()

p + theme_bw()
# there is still some distracting features. Also why are the ticks so small?
# we want to get rid of those unnecessary grid lines

# theme refers to the global theme options
p + theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# using a lot less ink. Dots are a bit tiny but that we sort in geom_point
# what about increasing the size of all the fonts?
p + theme_bw(base_size=16)+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# change the font?
# it aint easy, but can do

# options are serif, sans and mono, sorry no comic sans
p + theme_bw(base_size=16)+theme(text = element_text(family="serif"), panel.grid.major = element_blank(), panel.grid.minor = element_blank())


```

# And now all together!

```{r}

ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + 
  geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1, aes(color=trans))+
  stat_summary(fun="mean", linewidth=2, size=1, aes(color=trans), geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  theme_bw(base_size=16)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# not the most beautiful plot, let's tidy things up by using different panels
ggplot(mpg, aes(x=displ,y=hwy)) + 
  geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1)+
  stat_summary( fun="mean", size=1, linewidth=1, geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ #filter(mpg, class == "subcompact"), se = FALSE)
  theme_bw(base_size=16)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )+
  facet_grid(~drv)

# Not bad, still I don't like the panel dafaults, lets remove that unsightly gray box
ggplot(mpg, aes(x=displ,y=hwy)) + 
  geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1)+
  stat_summary( fun="mean", size=1, linewidth=1, geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ #filter(mpg, class == "subcompact"), se = FALSE)
  theme_bw(base_size=16)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        strip.background = element_blank()
  )+
  facet_grid(~drv)

```

# Overplotting problem (position layer)
# from RFDS examples
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")

ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")

ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
  
# Extensions
Dealing with missing data; what is a nan

# Colour blindness using colourBlindness package

```{r}

h<-ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + 
  geom_point() +
  stat_summary(fun.data="mean_se", linewidth=1, size=1, aes(color=trans))+
  stat_summary(fun="mean", linewidth=2, size=1, aes(color=trans), geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  theme_bw(base_size=16)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# let's simulate what colour blind people see
cvdPlot(h)

# lets replace so people can see it
cvdPlot(replacePlotColor(h))

# can I save this? it will sae the last plot
ggsave("filename.png", dpi=600, height=4, width=5, units="in")

# where is it going?
getwd(); setwd()

# what is going on?
h<-ggplot(mpg, aes(x=displ,y=hwy, color=drv)) + 
  geom_point(size=1) +
  stat_summary(fun.data="mean_se", linewidth=1, size=1, aes(color=trans))+
  stat_summary(fun="mean", linewidth=1, size=1, aes(color=trans), geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  theme_bw(base_size=8)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# lets replace so people can see it
cvdPlot(replacePlotColor(h))


# how to change the palette, so we can save the new plot
replacePlotColor(h)

# how to change the ggplot2 code so we have a safe palette?
# we have :
colorBlindness::safeColors

# we can now apply to our color property
# then we get an error, cute but not very practical, we can use the colourblindness function isntead? ...
h<-ggplot(filter(mpg,drv==c('f','m')), aes(x=displ,y=hwy, color=drv, Values=t(c(safeColors[1],safeColors[2])))) + 
  geom_point(size=1) +
  stat_summary(fun.data="mean_se", linewidth=1, size=1)+
  stat_summary(fun="mean", linewidth=1, size=1,  geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  theme_bw(base_size=8)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# instead we could just use the viridis package, https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html

# we can use colourBlindness to check the result
install.packages("viridis")
library(viridis)
h<-ggplot(filter(mpg,drv==c('f','r')), aes(x=displ,y=hwy, color=drv)) + 
  geom_point(size=1) +
  stat_summary(fun.data="mean_se", linewidth=1, size=1)+
  stat_summary(fun="mean", linewidth=1, size=1, geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  scale_fill_viridis()+
  theme_bw(base_size=8)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# THIS IS NOT WORKING??
#install.packages("viridis")
#library(viridis)
# Vignette("viridis")
h<-ggplot(filter(mpg,drv==c('f','r')), aes(x=displ,y=hwy, color=drv)) + 
  geom_point(size=1) +
  stat_summary(fun.data="mean_se", linewidth=1, size=1)+
  stat_summary(fun="mean", linewidth=1, size=1, geom="line")+    
  # I can commend here, it won't generate an error, ain't that neat?
  geom_smooth()+ 
  scale_color_manual(viridis+
  theme_bw(base_size=8)+
  theme(text = element_text(family="serif"), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()
  )

# Or change the colours from the saved file?
  
# they can be called by name or code, if you are interested in a very specific colour
# check here: http://sape.inf.usi.ch/quick-reference/ggplot2/colour

# You can specify the colors manually?
# Where to find them?
# sp + scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))


```

# Saving your graphs: Publication quality production

Use ggsave to increase dpi from base R level (72 dpi) and to defining figure dimensions.
E.g. nature: 3.5 in (89 mm), for a single column figure. 183 for a double column figure. 7.2

600 should cover the upper limit for publishers 

```{r}
ggsave("filename.png", dpi=600, height=4, width=5, units="in")

ggsave(P3, file="Fig2B.pdf", device="pdf",dpi=300)

```

# Further
GGplot comes with a massive amount of options. You can check this rather overwhelming "cheat sheet" to get a glimpse: <https://github.com/rstudio/cheatsheets/blob/main/data-visualization.pdf>


# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0.2, sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0., sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0., sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- 1/exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0., sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- 1/exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0., sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- 1/exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Load required package
if (!requireNamespace("BayesFactor", quietly = TRUE)) {
install.packages("BayesFactor")
}
library(BayesFactor)
# Simulate data for two groups
n_observations <- 100  # Sample size per group
group1 <- rnorm(n_observations, mean = 0, sd = 1)  # Group 1: Mean = 0
group2 <- rnorm(n_observations, mean = 0., sd = 1)  # Group 2: Mean = 0.5
# Sequential testing
threshold <- 10  # Bayes factor threshold for strong evidence
bf_values <- numeric(n_observations)  # Store Bayes factors
# we start at 2, we need at least 2 observations
for (i in 2:(n_observations)) {
grp1 <- group1[1:i]
grp2 <- group2[1:i]
# Compute Bayes factor
bf <- ttestBF(grp1,grp2, paired=FALSE)  # Compute Bayes factor
# Check if bf is a valid object
if (is.null(bf)) {
stop("Bayes factor computation returned NULL.")
}
bf_values[i] <- 1/exp(bf@bayesFactor$bf)  # Extract BF10 (evidence in favour of hypothesis)
}
# Plot Bayes factors over time
plot(1:(n_observations), bf_values, type = "l", col = "blue", lwd = 2,
xlab = "Sample Size per Group", ylab = "Bayes Factor (BF10)",
main = "Sequential Testing with Bayes Factors")
abline(h = threshold, col = "red", lty = 2)  # Add threshold line
# Function to simulate sequential testing
simulate_sequential <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max / 2, mean = 0, sd = 1)
group2 <- rnorm(n_max / 2, mean = effect_size, sd = 1)
for (i in 1:(n_max / 2)) {
data <- data.frame(
value = c(group1[1:i], group2[1:i]),
group = factor(rep(c("Group1", "Group2"), each = i))
)
bf <- ttestBF(value ~ group, data = data)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
sample_sizes <- sapply(effect_sizes, simulate_sequential, n_max = 100, threshold = 10)
# Function to simulate sequential testing
simulate_sequential <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
for (i in 1:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(value ~ group, data = data)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
sample_sizes <- sapply(effect_sizes, simulate_sequential, n_max = 100, threshold = 10)
simulate_sequential <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
for (i in 1:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(grp1, grp2, paired=FALSE)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
sample_sizes <- sapply(effect_sizes, simulate_sequential, n_max = 100, threshold = 10)
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
# we use sapply to apply a function
sample_sizes <- sapply(effect_sizes, simulate_sequential_fun, n_max = 100, threshold = 10)
# Plot results
plot(effect_sizes, sample_sizes, type = "b", col = "blue", lwd = 2,
xlab = "Effect Size", ylab = "Sample Size",
main = "Sample Size vs. Effect Size in Sequential Testing")
# Function to simulate sequential testing
simulate_sequential_fun <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
for (i in 1:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(grp1, grp2, paired=FALSE)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
# we use sapply to apply a function
sample_sizes <- sapply(effect_sizes, simulate_sequential_fun, n_max = 100, threshold = 10)
# Function to simulate sequential testing
simulate_sequential_fun <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
# need at least 2 obs
for (i in 2:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(grp1, grp2, paired=FALSE)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
# we use sapply to apply a function
sample_sizes <- sapply(effect_sizes, simulate_sequential_fun, n_max = 100, threshold = 10)
# Plot results
plot(effect_sizes, sample_sizes, type = "b", col = "blue", lwd = 2,
xlab = "Effect Size", ylab = "Sample Size",
main = "Sample Size vs. Effect Size in Sequential Testing")
# Function to simulate sequential testing
simulate_sequential_fun <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
# need at least 2 obs
for (i in 2:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(grp1, grp2, paired=FALSE)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
# we use sapply to apply a function
sample_sizes <- sapply(effect_sizes, simulate_sequential_fun, n_max = 100, threshold = 10)
# Plot results
plot(effect_sizes, sample_sizes, type = "b", col = "blue", lwd = 2,
xlab = "Effect Size", ylab = "Sample Size",
main = "Sample Size vs. Effect Size in Sequential Testing")
set.seed(42)
# Function to simulate sequential testing
simulate_sequential_fun <- function(effect_size, n_max, threshold) {
group1 <- rnorm(n_max, mean = 0, sd = 1)
group2 <- rnorm(n_max, mean = effect_size, sd = 1)
# need at least 2 obs
for (i in 2:(n_max)) {
grp1 = group1[1:i]
grp2 = group2[1:i]
bf <- ttestBF(grp1, grp2, paired=FALSE)
if (exp(bf@bayesFactor$bf) > threshold) {
return(i * 2)  # Return total sample size
}
}
return(n_max)  # Return max sample size if threshold not reached
}
# Simulate for different effect sizes
effect_sizes <- seq(0.2, 0.8, by = 0.2)
# we use sapply to apply a function
sample_sizes <- sapply(effect_sizes, simulate_sequential_fun, n_max = 100, threshold = 10)
# Plot results
plot(effect_sizes, sample_sizes, type = "b", col = "blue", lwd = 2,
xlab = "Effect Size", ylab = "Sample Size",
main = "Sample Size vs. Effect Size in Sequential Testing")
# Set seed for reproducibility
set.seed(42)
# Simulate data
n <- 30  # Sample size
mu <- 100  # True mean
sigma <- 15  # Standard deviation
# Generate random sample
data <- rnorm(n, mean = mu, sd = sigma)
# Calculate mean and 95% CI
mean_sample <- mean(data)
se <- sd(data) / sqrt(n)
ci_lower <- mean_sample - 1.96 * se
ci_upper <- mean_sample + 1.96 * se
# Print results
cat("Sample Mean:", round(mean_sample, 2), "\n")
cat("95% CI: [", round(ci_lower, 2), ",", round(ci_upper, 2), "]\n")
# Function to calculate CI width for different sample sizes
ci_width <- function(n, mu = 100, sigma = 15) {
data <- rnorm(n, mean = mu, sd = sigma)
se <- sd(data) / sqrt(n)
ci_width <- 2 * 1.96 * se  # Width of 95% CI
return(ci_width)
}
# Sample sizes to test
sample_sizes <- seq(10, 200, by = 10)
# Calculate CI widths
ci_widths <- sapply(sample_sizes, ci_width)
# Plot CI width vs. sample size
plot(sample_sizes, ci_widths, type = "b", col = "blue",
xlab = "Sample Size", ylab = "CI Width",
main = "Effect of Sample Size on CI Width")
# Function to calculate required sample size for a given CI width
required_sample_size <- function(desired_width, sigma = 15) {
n <- (2 * 1.96 * sigma / desired_width)^2
return(ceiling(n))  # Round up to the nearest whole number
}
# Desired CI width
desired_width <- 5
# Calculate required sample size
n_required <- required_sample_size(desired_width)
cat("Required Sample Size for CI Width of", desired_width, ":", n_required, "\n")
# Simulate data for two groups
n <- 30
mu1 <- 100
mu2 <- 110
sigma <- 15
group1 <- rnorm(n, mean = mu1, sd = sigma)
group2 <- rnorm(n, mean = mu2, sd = sigma)
# Calculate means and CIs
mean1 <- mean(group1)
mean2 <- mean(group2)
se1 <- sd(group1) / sqrt(n)
se2 <- sd(group2) / sqrt(n)
ci1 <- c(mean1 - 1.96 * se1, mean1 + 1.96 * se1)
ci2 <- c(mean2 - 1.96 * se2, mean2 + 1.96 * se2)
# Print results
cat("Group 1: Mean =", round(mean1, 2), ", 95% CI =", round(ci1, 2), "\n")
cat("Group 2: Mean =", round(mean2, 2), ", 95% CI =", round(ci2, 2), "\n")
# Calculate difference in means and CI
mean_diff <- mean2 - mean1
se_diff <- sqrt(se1^2 + se2^2)
ci_diff <- c(mean_diff - 1.96 * se_diff, mean_diff + 1.96 * se_diff)
# Plot the effect size and CI
plot(1, mean_diff, ylim = c(ci_diff[1] - 5, ci_diff[2] + 5), pch = 19,
xlab = "Effect Size", ylab = "Difference in Means",
main = "Confidence Interval for Effect Size")
arrows(1, ci_diff[1], 1, ci_diff[2], angle = 90, code = 3, length = 0.1, col = "blue")
# Simulate data for two groups
n <- 30
mu1 <- 100
mu2 <- 110
sigma <- 15
group1 <- rnorm(n, mean = mu1, sd = sigma)
group2 <- rnorm(n, mean = mu2, sd = sigma)
# Calculate means and CIs
mean1 <- mean(group1)
mean2 <- mean(group2)
se1 <- sd(group1) / sqrt(n)
se2 <- sd(group2) / sqrt(n)
ci1 <- c(mean1 - 1.96 * se1, mean1 + 1.96 * se1)
ci2 <- c(mean2 - 1.96 * se2, mean2 + 1.96 * se2)
# Print results
cat("Group 1: Mean =", round(mean1, 2), ", 95% CI =", round(ci1, 2), "\n")
cat("Group 2: Mean =", round(mean2, 2), ", 95% CI =", round(ci2, 2), "\n")
# Function to calculate required sample size for a given CI width
required_sample_size <- function(desired_width, sigma = 15) {
n <- (2 * 1.96 * sigma / desired_width)^2
return(ceiling(n))  # Round up to the nearest whole number
}
# Desired CI width
desired_width <- 5
# Calculate required sample size
n_required <- required_sample_size(desired_width)
cat("Required Sample Size for CI Width of", desired_width, ":", n_required, "\n")
# Function to calculate required sample size for a given CI width
required_sample_size_fun <- function(desired_width, sigma = 15) {
n <- (2 * 1.96 * sigma / desired_width)^2
return(ceiling(n))  # Round up to the nearest whole number
}
# Desired CI width
desired_width <- 5
# Calculate required sample size
n_required <- required_sample_size_fun(desired_width)
cat("Required Sample Size for CI Width of", desired_width, ":", n_required, "\n")
# Function to calculate required sample size for a given CI width
required_sample_size_fun <- function(desired_width, sigma = 15) {
n <- (2 * 1.96 * sigma / desired_width)^2
return(ceiling(n))  # Round up to the nearest whole number
}
# Desired CI width
desired_width <- 5
# Calculate required sample size
n_required <- required_sample_size_fun(desired_width)
cat("Required Sample Size for CI Width of", desired_width, ":", n_required, "\n")
# Simulate data for two groups
n <- 30
mu1 <- 100
mu2 <- 110
sigma <- 15
group1 <- rnorm(n, mean = mu1, sd = sigma)
group2 <- rnorm(n, mean = mu2, sd = sigma)
# Calculate means and CIs
mean1 <- mean(group1)
mean2 <- mean(group2)
se1 <- sd(group1) / sqrt(n)
se2 <- sd(group2) / sqrt(n)
ci1 <- c(mean1 - 1.96 * se1, mean1 + 1.96 * se1)
ci2 <- c(mean2 - 1.96 * se2, mean2 + 1.96 * se2)
# Print results
cat("Group 1: Mean =", round(mean1, 2), ", 95% CI =", round(ci1, 2), "\n")
cat("Group 2: Mean =", round(mean2, 2), ", 95% CI =", round(ci2, 2), "\n")
# Calculate difference in means and CI
mean_diff <- mean2 - mean1
se_diff <- sqrt(se1^2 + se2^2)
ci_diff <- c(mean_diff - 1.96 * se_diff, mean_diff + 1.96 * se_diff)
# Plot the effect size and CI
plot(1, mean_diff, ylim = c(ci_diff[1] - 5, ci_diff[2] + 5), pch = 19,
xlab = "Effect Size", ylab = "Difference in Means",
main = "Confidence Interval for Effect Size")
arrows(1, ci_diff[1], 1, ci_diff[2], angle = 90, code = 3, length = 0.1, col = "blue")
# Simulate multiple samples and their CIs
n_samples <- 50
n <- 30
mu <- 100
sigma <- 15
# Generate samples and calculate CIs
results <- replicate(n_samples, {
data <- rnorm(n, mean = mu, sd = sigma)
mean_sample <- mean(data)
se <- sd(data) / sqrt(n)
ci_lower <- mean_sample - 1.96 * se
ci_upper <- mean_sample + 1.96 * se
c(mean = mean_sample, ci_lower = ci_lower, ci_upper = ci_upper)
})
# Convert to data frame
results_df <- as.data.frame(t(results))
# Plot the CIs
library(ggplot2)
ggplot(results_df, aes(x = 1:n_samples, y = mean)) +
geom_point() +
geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2) +
labs(title = "Confidence Intervals Across Samples",
x = "Sample Number", y = "Mean Estimate") +
theme_minimal()
# Simulate data for two groups
n <- 30
mu1 <- 100
mu2 <- 110
sigma <- 15
group1 <- rnorm(n, mean = mu1, sd = sigma)
group2 <- rnorm(n, mean = mu2, sd = sigma)
# Calculate means and CIs
mean1 <- mean(group1)
mean2 <- mean(group2)
se1 <- sd(group1) / sqrt(n)
se2 <- sd(group2) / sqrt(n)
ci1 <- c(mean1 - 1.96 * se1, mean1 + 1.96 * se1)
ci2 <- c(mean2 - 1.96 * se2, mean2 + 1.96 * se2)
# Print results
cat("Group 1: Mean =", round(mean1, 2), ", 95% CI =", round(ci1, 2), "\n")
cat("Group 2: Mean =", round(mean2, 2), ", 95% CI =", round(ci2, 2), "\n")
# Calculate difference in means and CI
mean_diff <- mean2 - mean1
se_diff <- sqrt(se1^2 + se2^2)
ci_diff <- c(mean_diff - 1.96 * se_diff, mean_diff + 1.96 * se_diff)
# Plot the effect size and CI
plot(1, mean_diff, ylim = c(ci_diff[1] - 5, ci_diff[2] + 5), pch = 19,
xlab = "Effect Size", ylab = "Difference in Means",
main = "Confidence Interval for Effect Size")
arrows(1, ci_diff[1], 1, ci_diff[2], angle = 90, code = 3, length = 0.1, col = "blue")
